<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js 배열 메서드</title>
</head>
<body>
  <script>
    /* 
    배열의 메서드(method)

    / 기존 데이터를 안바꾼다
    1. join([연결자(구분자)]): 기본값 ,
    2. concat: 배열 추가
    5. slice: 1~4번 바로 전까지 (음수는 꺼꾸로인데 -1 부터)

    / 기존 데이터를 바꾼다
    3. reverse: 배열 반대로 정렬 
    4. sort: 오름차순 정렬 - 숫자, 문자(한글, 영문)
    6. splice: 기존 데이터 삭제
    
    7. push: 데이터 입력
    8. pop
    9. shift
    10. unshift
    11. forEach
    12. map: 새 배열 생성
    13. filter: 새 배열 생성
    14. indexOf: 
    15. lastIndexOf
    */
   
    // 배열이름.메서드()
    let result;
    // 배열.join(): ,
    document.write('join -------------------------------<br>');
    const cities = ['서울', '경기', '인천'];
    result = cities.join();
    document.write(result + '<br>');
    document.write(typeof result + '<br>');
    result = cities.join('-');
    document.write(result + '<br>');
    document.write(typeof cities + '<br>');
    result = cities.join(' 그리고 ');
    document.write(result + '<br><br>');

    document.write('concat -------------------------------<br>');
    const fruit = ['사과', '딸기', '포도'];
    const names = ['길동', '야옹', '멍멍'];

    // 배열.concat(값, 값, ...)
    result = cities.concat('부산', '광주', '대구');
    document.write(result + '<br>');
    document.write(cities + '<br>');
    document.write(typeof result + '<br>');
    // 메서드 체이닝(메서드를 섞어 씀)
    result = cities.concat(fruit).join('-');
    document.write(result + '<br>');
    result = cities.concat(fruit, name);
    document.write(result + '<br><br>');

    document.write('reverse -------------------------------<br>');
    // 배열.reverse()
    const nums = [9,8,7,6,5,4,3,2,1];
    result = nums.join();
    document.write(result + '<br>');
    result = nums.reverse();
    document.write(result + '<br>');
    result = names.join();
    document.write(result + '<br>');
    result = names.reverse();
    document.write(result + '<br>');
    document.write(names + '<br><br>');

    document.write('sort -------------------------------<br>');
    // 배열.sort()
    const ndata1=[19, 38, 67, 26, 55, 24, 53, 12, 31]; 
    const ndata2=[132, 2, 41, 123, 45, 1234, 6, 29, 4567]; 
    const edata=['Apple', 'Html', 'Game', 'Computer', 'Java']; 
    let kdata=['서울', '부산', '구포', '대구', '인천'];

    result = ndata1.sort();
    document.write(result + '<br>');
    /*
    sort(비교함수)
    함수 데이터: function(){}
    sort(function(a, b){return a-b};)
    화살표 함수: sort((a, b)=>a-b;)
    */
    // result = ndata2.sort(
    //   function(a, b){return a-b;} // 콜백 함수
    // );
    result = ndata2.sort(
      // (a, b)=>{return a-b;} // 화살표 함수
      (a, b) => a-b // 화살표 함수
    );
    document.write(result + '<br>');
    result = edata.sort();
    document.write(result + '<br>');
    result = kdata.sort();
    document.write(result + '<br>');
    document.write(kdata + '<br><br>');

    document.write('slice -------------------------------<br>');
    // 배열.slice(인덱스1, 인덱스2)
    kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종'];
    result = kdata.slice(0, 4);
    document.write(result + '<br>');
    result = kdata.slice(2, -1);
    document.write(result + '<br>');
    result = kdata.slice(-4, -2);
    document.write(typeof result + '<br>');
    document.write(result + '<br>');
    document.write(kdata + '<br><br>');

    // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ여기부터 map 전까지 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

    document.write('splice -------------------------------<br>');
    // 배열.splice(시작index, [삭제개수], [요소1, 요소2, ...])
    // 기존 배열이 변경
    document.write(kdata + '<br>');
    document.write(kdata.slice(1, 3) + '<br>');
    result = kdata.splice(1, 2); // 1번 인덱스부터 2개를 삭제하여 반환
    document.write(result + '<br>');
    document.write(kdata + '<br>');
    // [서울, 대구, 인천, 대전, 세종]
    result = kdata.splice(1, 1, '수원', '용인');
    document.write(result + '<br>');
    document.write(kdata + '<br>');
    // 요소 삭제 - 음수 인덱스
    result = kdata.splice(-2, 1);
    document.write('요소 삭제: ' + result + '<br>');
    // [서울, 수원, 용인, 인천, 대전, 세종]

    // 배열명.splice(시작 index, 삭제 개수, ...아이템)
    // 시작 인덱스부터 삭제개수만큼 반환
    result = kdata.splice(2, Number.MAX_VALUE);
    document.write(result + '<br>'); // [용인, 인천, 대전, 세종]
    document.write(kdata + '<br><br>'); // [서울, 수원]

    
    document.write('forEach -------------------------------<br>');
    // forEach
    let datas = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let sum = 0;
    
    datas.forEach(function(val) {
      sum += val;
    })
    document.write(`1~10까지의 합: ${sum} <br><br>`);
    console.log(datas);
    
    document.write('push & pop -------------------------------<br>');
    // push & pop
    document.write('shift -------------------------------<br>');
    // shift
    document.write('unshift -------------------------------<br>');
    // unshift

    document.write('map -------------------------------<br>');
    // map(콜백함수)
    // 배열명.map(function(val, [idx], [arr]){});
    result = datas.map(function(val){
      return val * val;
    })
    document.write(`새 배열: ${datas}<br>`);
    document.write(`기존 배열: ${result}<br>`);

    document.write('filter -------------------------------<br>');
    // filter(콜백함수)
    // 배열명.filter(function(val, [idx], [arr]){
    //   return 조건식;
    // });
    result = datas.filter(function(val){
      return val >= 6;
    })
    document.write(`새 배열: ${datas}<br>`);
    document.write(`기존 배열: ${result}<br>`);

    document.write('indexOf -------------------------------<br>');
    // indexOf(콜백함수)

  </script>
</body>
</html>