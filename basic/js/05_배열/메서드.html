<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js 배열 메서드</title>
</head>
<body>
  <script>
    /* 
    배열의 메서드(method)

    / 기존 데이터를 안바꾼다
    1. join([연결자(구분자)]): 기본값 ,
    2. concat: 배열 추가
    5. slice: 1~4번 바로 전까지 (음수는 꺼꾸로인데 -1 부터)

    / 기존 데이터를 바꾼다
    3. reverse: 배열 반대로 정렬 
    4. sort: 오름차순 정렬 - 숫자, 문자(한글, 영문)
    
    6. splice
    7. pop
    8. push
    9. shift
    10. unshift
    11. forEach
    12. map
    13. filter
    14. indexOf
    15. lastIndexOf
    16. 
    */
   
    // 배열이름.메서드()
    let result;
    // 배열.join(): ,
    document.write('join -------------------------------<br>');
    const cities = ['서울', '경기', '인천'];
    result = cities.join();
    document.write(result + '<br>');
    document.write(typeof result + '<br>');
    result = cities.join('-');
    document.write(result + '<br>');
    document.write(typeof cities + '<br>');
    result = cities.join(' 그리고 ');
    document.write(result + '<br><br>');

    document.write('concat -------------------------------<br>');
    const fruit = ['사과', '딸기', '포도'];
    const names = ['길동', '야옹', '멍멍'];

    // 배열.concat(값, 값, ...)
    result = cities.concat('부산', '광주', '대구');
    document.write(result + '<br>');
    document.write(cities + '<br>');
    document.write(typeof result + '<br>');
    // 메서드 체이닝(메서드를 섞어 씀)
    result = cities.concat(fruit).join('-');
    document.write(result + '<br>');
    result = cities.concat(fruit, name);
    document.write(result + '<br><br>');

    document.write('reverse -------------------------------<br>');
    // 배열.reverse()
    const nums = [9,8,7,6,5,4,3,2,1];
    result = nums.join();
    document.write(result + '<br>');
    result = nums.reverse();
    document.write(result + '<br>');
    result = names.join();
    document.write(result + '<br>');
    result = names.reverse();
    document.write(result + '<br>');
    document.write(names + '<br><br>');

    document.write('sort -------------------------------<br>');
    // 배열.sort()
    const ndata1=[19, 38, 67, 26, 55, 24, 53, 12, 31]; 
    const ndata2=[132, 2, 41, 123, 45, 1234, 6, 29, 4567]; 
    const edata=['Apple', 'Html', 'Game', 'Computer', 'Java']; 
    let kdata=['서울', '부산', '구포', '대구', '인천'];

    result = ndata1.sort();
    document.write(result + '<br>');
    /*
    sort(비교함수)
    함수 데이터: function(){}
    sort(function(a, b){return a-b};)
    화살표 함수: sort((a, b)=>a-b;)
    */
    // result = ndata2.sort(
    //   function(a, b){return a-b;} // 콜백 함수
    // );
    result = ndata2.sort(
      // (a, b)=>{return a-b;} // 화살표 함수
      (a, b) => a-b // 화살표 함수
    );
    document.write(result + '<br>');
    result = edata.sort();
    document.write(result + '<br>');
    result = kdata.sort();
    document.write(result + '<br>');
    document.write(kdata + '<br><br>');

    document.write('slice -------------------------------<br>');
    // 배열.slice(인덱스1, 인덱스2)
    kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종'];
    result = kdata.slice(0, 4);
    document.write(result + '<br>');
    result = kdata.slice(2, -1);
    document.write(result + '<br>');
    result = kdata.slice(-4, -2);
    document.write(typeof result + '<br>');
    document.write(result + '<br>');
    document.write(kdata + '<br><br>');

    document.write('splice -------------------------------<br>');

  </script>
</body>
</html>